% Created 2013-09-19 Thu 07:12
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{hyperref}
\tolerance=1000
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{matrix,arrows,positioning,scopes,chains}
\tikzset{node distance=2cm, auto}
\author{The Team of Fu}
\date{\today}
\title{Arithmetic on Hash Maps}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.2.1 (Org mode 8.0.7)}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec-1}
\begin{description}
\item[{Remark}] This is a literate program. 
\footnote{See \url{http://en.wikipedia.org/wiki/Literate_programming}.} 
Source code \emph{and} PDF documentation spring
from the same, plain-text source files.
\end{description}
\section{Tangle to Leiningen}
\label{sec-2}

\begin{figure}[H]
\label{project-file}
\begin{verbatim}
(defproject ex1 "0.1.0-SNAPSHOT"
  :description "Project Fortune's Excel Processor"
  :url "http://example.com/TODO"
  :license {:name "TODO"
            :url "TODO"}
  :dependencies [[org.clojure/clojure  "1.5.1"]
                 [org.clojure/data.zip "0.1.1"]
                 [dk.ative/docjure     "1.6.0"]
                ]
  :repl-options {:init-ns ex1.core})
\end{verbatim}
\end{figure}

\subsection{The Documentation Subdirectory}
\label{sec-2-1}
Mimicking Leiningen's documentation subdirectory, it contains the
single file \verb+intro.md+, again in \verb+markdown+ syntax.
\begin{verbatim}
# Introduction to ex1
TODO: The project documentation is the .org file that produced 
this output, but it still pays to read
http://jacobian.org/writing/great-documentation/what-to-write/
\end{verbatim}

\subsection{Core Source File}
\label{sec-2-2}
By convention, the core source files go in a subdirectory named
\verb+./ex1/src/ex1+. This convention allows the Clojure namespaces
to map to Java packages.

The following is our core source file, explained in small pieces.
The \emph{org} file contains a spec for emitting the tangled source at
this point. This spec is not visible in the generated PDF file,
because we want to individually document the small pieces. The
invisible spec simply gathers up the source of the small pieces from
out of their explanations and then emits them into the source
directory tree, using another tool called
\emph{noweb}.\footnote{\url{http://orgmode.org/manual/Noweb-reference-syntax.html}}
This is not more complexity for you to learn, rather it is just a
way for you to feel comfortable with literate-programming magic.
\subsubsection{The Namespace}
\label{sec-2-2-1}
First, we must mention the libraries we're using. This is pure
ceremony, and we get to the meat of the code immediately after. These
library-mentions correspond to the \verb|:dependencies| in the
\verb|project.clj| file above. Each \verb|:use| or \verb|:require|
below must correspond to either an explicit dependency in the
\verb|project.clj| file or to one of several implicitly loaded
libraries. Leiningen loads libraries by processing the
\verb|project.clj| file above. We bring symbols from those libraries
into our namespace so we can use the libraries in our core routines.

To ingest and compile raw Excel spreadsheets, we use the built-in
libraries \verb|clojure.zip| for tree navigation and
\verb|clojure.xml| for XML parsing, plus the third-party libraries
\verb|clojure.data.zip.xml| and \verb|dk.ative.docjure.spreadsheet|.
The following brings these libraries into our namespace:
\begin{figure}[H]
\label{main-namespace}
\begin{verbatim}
(ns ex1.core
  (:use [clojure.data.zip.xml :only (attr text xml->)]
        [dk.ative.docjure.spreadsheet] ) 
  (:require [clojure.xml :as xml]
            [clojure.zip :as zip]))
\end{verbatim}
\end{figure}
\subsubsection{Data Instances}
\label{sec-2-2-2}
Next, we create a couple of data instances to manipulate later in our
unit tests. The first one ingests a trivial XML file and the second
one converts the in-memory data structure into a
\emph{zipper},\footnote{\url{http://richhickey.github.io/clojure/clojure.zip-api.html}}
a very modern, functional tree-navigation facility. These instances
will test our ability to freely navigate the raw XML form of Excel
spreadsheets:
\begin{figure}[H]
\label{main-zippered}
\begin{verbatim}
(def xml (xml/parse "myfile.xml"))
(def zippered (zip/xml-zip xml))
\end{verbatim}
\end{figure}
\subsubsection{A Test Excel Spreadsheet}
\label{sec-2-2-3}
Finally, we use \verb|docjure| to emit a test Excel spreadsheet, which
we will read in our unit tests and verify some operations on it. This
code creates a workbook with a single sheet in a rather obvious way,
picks out the sheet and its header row, and sets some visual
properties on the header row. We can open the resulting spreadsheet in
Excel after running \verb|lein test| and verify that the
\verb|docjure| library works as advertised.
\begin{figure}[H]
\label{docjure-test-spreadsheet}
\begin{verbatim}
(let [wb (create-workbook "Price List"
                          [["Name"       "Price"]
                           ["Foo Widget" 100]
                           ["Bar Widget" 200]])
      sheet (select-sheet "Price List" wb)
      header-row (first (row-seq sheet))]
  (do
    (set-row-style!
      header-row
      (create-cell-style! wb
        {:background :yellow,
         :font       {:bold true}}))
    (save-workbook! "spreadsheet.xlsx" wb)))
\end{verbatim}
\end{figure}
\subsection{Core Unit-Test File}
\label{sec-2-3}
Unit-testing files go in a subdirectory named \verb+./ex1/test/ex1+.
Again, the directory-naming convention enables valuable shortcuts
from Leiningen.

As with the core source files, we include the built-in and downloaded
libraries, but also the \verb|test framework| and the \verb|core|
namespace, itself, so we can test the functions in the core.
\begin{figure}[H]
\label{main-test-namespace}
\begin{verbatim}
(ns ex1.core-test
  (:use [clojure.data.zip.xml :only (attr text xml->)]
        [dk.ative.docjure.spreadsheet]
  )
  (:require [clojure.xml :as xml]
            [clojure.zip :as zip]
            [clojure.test :refer :all]
            [ex1.core :refer :all]))
\end{verbatim}
\end{figure}

We now test that the zippered XML file can be accessed by the \emph{zipper}
operators. The main operator of interest is \verb|xml->|, which acts
a lot like Clojure's
\emph{fluent-style} \footnote{\url{http://en.wikipedia.org/wiki/Fluent_interface}}
\emph{threading} operator
\verb|->|.\footnote{\url{http://clojuredocs.org/clojure_core/clojure.core/-\%3E}}
It takes its first argument, a zippered XML file in this case, and
then a sequence of functions to apply. For instance, the following
XML file, when subjected to the functions \verb|:track|,
\verb|:name|, and \verb|text|, should produce \verb|'("Track one" "Track two")|
\begin{verbatim}
<songs>
  <track id="t1"><name>Track one</name></track>
  <ignore>pugh!</ignore>
  <track id="t2"><name>Track two</name></track>
</songs>
\end{verbatim}
Likewise, we can dig into the attributes with natural accessor
functions \footnote{Clojure treats colon-prefixed keywords as functions that
fetch the corresponding values from hashmaps, rather like the dot
operator in Java or JavaScript; Clojure also treats hashmaps as
functions of their keywords: the result of the function call
$\texttt{(\{:a 1\} :a)}$ is the same as the result of the function call
$\texttt{(:a \{:a 1\})}$}\#+name: docjure-test-namespace

\begin{figure}[H]
\label{test-zippered}
\begin{verbatim}
(deftest xml-zipper-test
  (testing "xml and zip on a trivial file."
    (are [a b] (= a b)
      (xml-> zippered :track :name text) '("Track one" "Track two")
      (xml-> zippered :track (attr :id)) '("t1" "t2"))))
\end{verbatim}
\end{figure}

Next, we ensure that we can faithfully read back the workbook we
created \emph{via} \verb|docjure|. Here, we use Clojure's
\verb|thread-last| macro to achieve fluent style:
\begin{figure}[H]
\label{test-docjure-read}
\begin{verbatim}
(deftest docjure-test
  (testing "docjure read"
    (is (= 

      (->> (load-workbook "spreadsheet.xlsx")
           (select-sheet "Price List")
           (select-columns {:A :name, :B :price}))

      [{:name "Name"      , :price "Price"}, ; don't forget header row
       {:name "Foo Widget", :price 100.0  },
       {:name "Bar Widget", :price 200.0  }]

      ))))
\end{verbatim}
\end{figure}
\section{A REPL-based Solution}
\label{sec-3}
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
\begin{enumerate}
\item Set up emacs and nRepl (TODO: explain; automate)
\item Edit your init.el file as follows (TODO: details)
\item Start nRepl while visiting the actual |project-clj| file.
\item Run code in the org-mode buffer with \verb|C-c C-c|; results of
evaluation are placed right in the buffer for inspection; they are
not copied out to the PDF file.
\end{enumerate}

\begin{verbatim}
[(xml-> zippered :track :name text)        ; ("Track one" "Track two")
 (xml-> zippered :track (attr :id))]       ; ("t1" "t2")
\end{verbatim}

\begin{verbatim}
(->> (load-workbook "spreadsheet.xlsx")
     (select-sheet "Price List")
     (select-columns {:A :name, :B :price}))
\end{verbatim}

\begin{verbatim}
(run-all-tests)
\end{verbatim}
\section{References}
\label{sec-4}

\section{Conclusion}
\label{sec-5}
Fu is Fortune.
% Emacs 24.2.1 (Org mode 8.0.7)
\end{document}