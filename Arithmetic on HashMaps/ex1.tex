% Created 2013-09-21 Sat 17:35
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{hyperref}
\tolerance=1000
\usepackage{savesym}
\savesymbol{iint}
\savesymbol{iiint}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{matrix,arrows,positioning,scopes,chains}
\tikzset{node distance=2cm, auto}
\usepackage{framed}
\usepackage[framed]{ntheorem}
\newframedtheorem{myrule}{Rule}[section]
\newframedtheorem{mydefinition}{Definition}[section]
\author{The Team of Fu}
\date{\today}
\title{Reversible Arithmetic on Collections}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.0)}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec-1}
\begin{description}
\item[{Remark}] This is a literate program.
\footnote{\url{http://en.wikipedia.org/wiki/Literate_programming}.}
Source code \emph{and} PDF documentation spring
from the same, plain-text source files.
\end{description}

\begin{verbatim}
[1, 2] + [3, 4] = [4, 6]
\end{verbatim}
We often encounter data records as hash-maps, sequences, or vectors.
Arithmetic on vectors is familiar from school math: to get the sum of
two vectors, just add the corresponding elements, first-to-first,
second-to-second, and so on.  Here's an example in two dimensions:

We don't need to write the commas (but we can if we want -- in Clojure,
they're just whitespace):
\begin{verbatim}
[1 2] + [3 4] = [4 6]
\end{verbatim}

Clojure's \emph{map} can already do this:
\begin{verbatim}
(map + [1 2] [3 4])
\end{verbatim}
\begin{verbatim}
==> [4 6]
\end{verbatim}

The same idea works in any number of dimensions and with any kind of
elements that can be added (any
\emph{field}:\footnote{\url{http://en.wikipedia.org/wiki/Field_(mathematics)}} integers,
complex numbers, quaternions.  It's the foundation of the important
theory of \emph{Vector Spaces} in
mathematics.\footnote{\url{http://en.wikipedia.org/wiki/Vector_space}}

Now, suppose you want to \emph{un-add} the result, \verb|[4 6]|? There is no
unique answer.  All the following are mathematically correct:
\begin{verbatim}
...
[-1 2] + [5 4] = [4 6]
[ 0 2] + [4 4] = [4 6]
[ 1 2] + [3 4] = [4 6]
[ 2 2] + [2 4] = [4 6]
[ 3 2] + [1 4] = [4 6]
...
\end{verbatim}
and a large infinity of more answers.

But, in our financial computations, we usually want this functionality
so we can undo a mistake, roll back a provisional result, perform a
backfill or allocation: in short, get back the original inputs.

Let's define a protocol for \emph{reversible arithmetic in vector spaces}
that captures the desired functionality.  We want a protocol because we
want several implementations with the same reversible arithmetic.  For
instance, we should be able to do similarly for hash-maps, which, after
all, are just sparse vectors with named components:
\begin{verbatim}
{:x 1, :y 2} + {:x 3, :y} = {:x 4, y:6}
\end{verbatim}

To get the desired behavior, we can't use \emph{map}; it doesn't work the
same on hash-maps.  We must use Clojure's \emph{merge-with}:
\begin{verbatim}
(merge-with + {:x 1, :y 2} {:x 3, :y 4})
\end{verbatim}
\begin{verbatim}
==> {:y  6, :x 4}
\end{verbatim}

We want to get rid of these annoying differences: the protocol for
reversible arithmetic on data rows should be the same for all collection
types.\footnote{including streams over time! Don't forget Rx and SRS.}  Along
the way, we'll do some hardening so that the implementations are robust
both mathematically and computationally.
\section{A Protocol for Reversible Arithmetic}
\label{sec-2}

Name our objects of interest \emph{algebraic vectors} to distinguish
them from Clojure's existing \emph{vector} type.  Borrowing an idiom from C\#
and .NET, name our protocol with an initial \emph{I} and with camelback
casing.  Don't misread \emph{IReversibleAlgebraicVector} as ``irreversible
algebraic vector,'' but rather read it as ``Interface to Reversible
Algebraic Vector,'' where ``Interface'' is a synonym for ``protocol.''

\begin{figure}[H]
\label{reversible-algebraic-vector-protocol}
\begin{verbatim}
(defprotocol IReversibleAlgebraicVector
  ;; binary operators
  (add   [a b])
  (sub   [a b])
  (inner [a b])
  ;; unary operators
  (scale [a scalar])
  ;; reverse any operation
  (undo [a])
  (redo [a])
)
\end{verbatim}
\end{figure}

\subsection{Implementing the Protocol for Vectors}
\label{sec-2-1}

As a first cut, package algebraic vectors in hash-maps that contain
enough information to reverse any computation.

First, define the base case: collections that hold data that can be
treated as ordinary, non-reversible vectors.  What kinds of things can
hold ordinary vector data?  They be things we can operate on with \emph{map}
or \emph{merge-with} to perform the basic, vector-space operations.
Therefore, the data must be a Clojure vector, list, or hash-map.

The higher-level case is to store reversing information in hash-maps
along with base-data. The base data will belong to the \emph{:data} key, by
convention.

\begin{mydefinition}[Reversible Algebraic Vector]
A \textbf{reversible algebraic vector} is either a \textbf{base-data} collection
or a hash-map containing a \texttt{:data} attribute. A base-data
collection is either a Clojure vector, list, or hash-map that does
not contain a \texttt{:data} attribute. If a reversible algebraic vector
does contain a \texttt{:data} attribute, the value of that attribute
is a base-data collection.
\end{mydefinition}

Here is a \emph{fluent}, type-checking function that either returns its input
-- like the \emph{identity} function -- or throws an exception if something
is wrong.

\begin{figure}[H]
\label{check-data-type}
\begin{verbatim}
(defn- check-data-type [that]
  (let [t (type that)]
    (if (or (= t (type []))
            (= t (type '()))  ; empty list is special
            (= t (type '(0))) ; this list is ordinary
            (= t (type {})))
      that
      (throw (IllegalArgumentException.
        (str "This type of object can't hold vector data: " t))))))
\end{verbatim}
\end{figure}

Now we can formally define the reversible algebraic vector:

Now we need a way to get the data out of any reversible algebraic
vector. We must explicitly check for existence of \emph{:data} so that we can
tell the difference between a hash-map that has \emph{:data} whose value is
\emph{nil} and a hash-map that has no \emph{:data}; the prettier code

\begin{verbatim}
(:data that)
\end{verbatim}

does not distinguish those two cases.

\begin{figure}[H]
\label{get-data-helper}
\begin{verbatim}
(defmulti  get-data type)
(defmethod get-data (type [])   [that] that)
(defmethod get-data (type '())  [that] that)
(defmethod get-data (type '(0)) [that] that)
(defmethod get-data (type {})   [that]
  (if (contains? that :data)
    (check-data-type (:data that))
    that))
(defmethod get-data :default    [that]
  (throw (IllegalArgumentException.
    (str "get-data doesn't like this food: " that))))
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{test-get-data-helper}
\begin{verbatim}
(deftest get-data-helper-test
  (testing "get-data-helper"
    (are [val] (thrown? IllegalArgumentException val)
      (get-data 42)
      (get-data 'a)
      (get-data :a)
      (get-data "a")
      (get-data \a)
      (get-data #inst "2012Z")
      (get-data #{})
      (get-data nil)
      (get-data {:data 42 })
      (get-data {:data 'a })
      (get-data {:data :a })
      (get-data {:data "a"})
      (get-data {:data \a })
      (get-data {:data #inst "2012Z"})
      (get-data {:data #{} })
      (get-data {:data nil })
    )
    (are [x y] (= x y)
          [] (get-data  [])
         '() (get-data '())
          {} (get-data  {})

         [0] (get-data  [0])
        '(0) (get-data '(0))
      {:a 0} (get-data  {:a 0})

       [1 0] (get-data  [1 0])
      '(1 0) (get-data '(1 0))
 {:a 0 :b 1} (get-data  {:b 1 :a 0})

        [42] (get-data {:a 1 :data [42]})
       '(42) (get-data {:a 1 :data '(42)})
     {:a 42} (get-data {:a 1 :data {:a 42}})

          [] (get-data {:a 1 :data []})
         '() (get-data {:a 1 :data '()})
          {} (get-data {:a 1 :data {}})
    )
))
\end{verbatim}
\end{figure}

Here are unit tests for these helpers that show how they enforce the
definition.

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{/Users/rebcabin/tmp/BB_00000.PDF}
  \caption{\label{fig:fufortune}This means ``Fortune'' and is pronounced ``Fu''.}
\end{figure}

\begin{figure}[H]
\label{reversible-algebraic-vector-on-vector}
\begin{verbatim}
(defrecord ReversibleVector [a-vector]
  IReversibleAlgebraicVector
  (add   [a b] {:left-prior a, :right-prior b,
                :operation 'add, :data (map + (get-data a)
                                              (get-data b))})
  (sub   [a b] nil)
  (inner [a b] nil)
  (scale [a scalar] nil)
  (undo  [a] nil)
  (redo  [b] nil))
\end{verbatim}
\end{figure}
\section{Unit-Tests}
\label{sec-3}

\begin{figure}[H]
\label{test-namespace}
\begin{verbatim}
(ns ex1.core-test
  (:require [clojure.test :refer :all]
            [ex1.core     :refer :all]))
\end{verbatim}
\end{figure}
\section{REPLing}
\label{sec-4}
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
\begin{enumerate}
\item Set up emacs and nRepl (TODO: explain; automate)
\item Edit your init.el file as follows (TODO: details)
\item Start nRepl while visiting the actual |project-clj| file.
\item Run code in the org-mode buffer with \verb|C-c C-c|; results of
evaluation are placed right in the buffer for inspection; they are
not copied out to the PDF file.
\end{enumerate}
% Emacs 24.3.1 (Org mode 8.0)
\end{document}
