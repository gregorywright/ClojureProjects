% Created 2013-09-20 Fri 16:01
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{hyperref}
\tolerance=1000
\usepackage{savesym}
\savesymbol{iint}
\savesymbol{iiint}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{matrix,arrows,positioning,scopes,chains}
\tikzset{node distance=2cm, auto}
\usepackage{framed}
\usepackage[framed]{ntheorem}
\newframedtheorem{myrule}{Rule}[section]
\author{The Team of Fu}
\date{\today}
\title{Reversible Arithmetic on Collections}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.0)}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec-1}
\begin{description}
\item[{Remark}] This is a literate program.
\footnote{\url{http://en.wikipedia.org/wiki/Literate_programming}.}
Source code \emph{and} PDF documentation spring
from the same, plain-text source files.
\end{description}

We often encounter data records as hash maps, sequences, or vectors.
Arithmetic on vectors is familiar from school math: to get the sum of
two vectors, just add the corresponding elements, first-to-first,
second-to-second, and so on.  Here's an example in two dimensions:
\begin{verbatim}
[1, 2] + [3, 4] = [4, 6]
\end{verbatim}

We don't need to write the commas (but we can if we want -- in Clojure,
they're just whitespace):
\begin{verbatim}
[1 2] + [3 4] = [4 6]
\end{verbatim}

Clojure's \emph{map} can already do this:
\begin{verbatim}
(map + [1 2] [3 4])
\end{verbatim}
\begin{verbatim}
==> [4 6]
\end{verbatim}

The same idea works in any number of dimensions and with any kind of
elements that can be added (any
\emph{field}:\footnote{\url{http://en.wikipedia.org/wiki/Field_(mathematics)}} integers,
complex numbers, quaternions.  It's the foundation of the important
theory of \emph{Vector Spaces} in
mathematics.\footnote{\url{http://en.wikipedia.org/wiki/Vector_space}}

Now, suppose you want to \emph{un-add} the result, \verb|[4 6]|? There is no
unique answer.  All the following are mathematically correct:
\begin{verbatim}
...
[-1 2] + [5 4] = [4 6]
[ 0 2] + [4 4] = [4 6]
[ 1 2] + [3 4] = [4 6]
[ 2 2] + [2 4] = [4 6]
[ 3 2] + [1 4] = [4 6]
...
\end{verbatim}
and a large infinity of more answers.

But, in our financial computations, we usually want this functionality
so we can undo a mistake, roll back a provisional result, perform a
backfill or allocation: in short, get back the original inputs.

Let's define a protocol for \emph{reversible arithmetic in vector spaces}
that captures the desired functionality.  We want a protocol because we
want several implementations with the same reversible arithmetic.  For
instance, we should be able to do similarly for hash-maps, which, after
all, are just sparse vectors with named components:
\begin{verbatim}
{:x 1, :y 2} + {:x 3, :y} = {:x 4, y:6}
\end{verbatim}

To get the desired behavior, we can't use \emph{map}; it doesn't work the
same on hash-maps.  We must use Clojure's \emph{merge-with}:
\begin{verbatim}
(merge-with + {:x 1, :y 2} {:x 3, :y 4})
\end{verbatim}
\begin{verbatim}
==> {:y  6, :x 4}
\end{verbatim}

We want to get rid of these annoying differences: the protocol for
adding data rows should be the same for all collection
types.\footnote{including streams over time! Don't forget Rx and SRS.}  Along
the way, we'll do some hardening so that the implementations are robust
both mathematically and computationally.
\section{A Protocol for Reversible Arithmetic}
\label{sec-2}

First, name our objects of interest \emph{algebraic vectors} to distinguish
them from Clojure's existing \emph{vector} type.  Borrowing an idiom from C\#
and .NET, name our protocol with an initial \emph{I} and with camelback
casing.  Don't misread \emph{IReversibleAlgebraicVector} as ``irreversible
algebraic vector,'' but rather read it as ``Interface to Reversible
Algebraic Vector,'' where ``Interface'' is a synonym for ``protocol.''

\begin{figure}[H]
\label{reversible-algebraic-vector-protocol}
\begin{verbatim}
(defprotocol IReversibleAlgebraicVector
  ;; binary operators
  (add   [a b])
  (sub   [a b])
  (inner [a b])
  ;; unary operators
  (scale [a scalar])
  ;; reverse any operation
  (undo [a])
  (redo [a])
)
\end{verbatim}
\end{figure}

\subsection{Implementing the Protocol for Vectors}
\label{sec-2-1}

As a first cut, package Clojure vectors in hash-maps that contain enough
information to reverse any computation.

Start with a little helper to get data from a vector that may be either
a basic Clojure vector or one of our reversible algebraic vectors.
Define it as a \emph{multimethod} since we anticipate needing it for every
basic type that can hold a reversible algebraic vector, namely for
vectors, lists, and hash-maps. If the hash-map has a value for key
\emph{:data}, then return that value. Otherwise, return the given
hash-map. This implies our first rule:
\begin{myrule}[Data]
A reversible algebraic vector is a hash-map, list, or ordinary Clojure
vector. If it is a hash-map, it either has a \texttt{:data}
attribute or not.
If it has a \texttt{:data} attribute, then its data is the value of that
attribute. Otherwise, its data is the
hash-map is itself.
\end{myrule}


\begin{figure}[H]
\label{get-data-helper}
\begin{verbatim}
(defmulti get-data type)
(defmethod get-data (type [])  [that] that)
(defmethod get-data (type '()) [that] that)
(defmethod get-data (type {}) (or (:data that) that))
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{reversible-algebraic-vector-on-vector}
\begin{verbatim}
(defrecord ReversibleVector [a-vector]
  IReversibleAlgebraicVector
  (add [a b] {:left-prior a, :right-prior b,
              :operation 'add, :data (map + (get-data a)
                                            (get-data b))})
  (sub [a b] nil)
  (inner [a b] nil)
  (scale [a scalar] nil)
  (undo [a] nil)
  (undo [b] nil))
\end{verbatim}
\end{figure}

\section{Functions}
\label{sec-3}
\begin{figure}[H]
\label{main-functions}
\begin{verbatim}
(def x 42)
(defn foo [] x)
\end{verbatim}
\end{figure}
\section{Unit-Tests}
\label{sec-4}

\begin{figure}[H]
\label{test-namespace}
\begin{verbatim}
(ns ex1.core-test
  (:require [clojure.test :refer :all]
            [ex1.core     :refer :all]))
\end{verbatim}
\end{figure}

\begin{figure}[H]
\label{test-functions}
\begin{verbatim}
(deftest null-test
  (testing "null test"
    (is (= (merge-with + {:x 1 :y 2} {:x 3 :y 4}) {:x 4 :y 6}))
    (is (= 1 1))
  ))
\end{verbatim}
\end{figure}
\section{REPLing}
\label{sec-5}
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
\begin{enumerate}
\item Set up emacs and nRepl (TODO: explain; automate)
\item Edit your init.el file as follows (TODO: details)
\item Start nRepl while visiting the actual |project-clj| file.
\item Run code in the org-mode buffer with \verb|C-c C-c|; results of
evaluation are placed right in the buffer for inspection; they are
not copied out to the PDF file.
\end{enumerate}

\begin{verbatim}
(run-all-tests)
\end{verbatim}

\begin{verbatim}
(foo)
\end{verbatim}
% Emacs 24.3.1 (Org mode 8.0)
\end{document}
