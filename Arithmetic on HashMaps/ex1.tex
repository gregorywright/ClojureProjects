% Created 2013-09-22 Sun 08:33
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{hyperref}
\tolerance=1000
\usepackage{savesym}
\savesymbol{iint}
\savesymbol{iiint}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{matrix,arrows,positioning,scopes,chains}
\tikzset{node distance=2cm, auto}
\usepackage{framed}
\usepackage[framed]{ntheorem}
\newframedtheorem{myrule}{Rule}[section]
\newframedtheorem{mydefinition}{Definition}[section]
\author{The Team of Fu}
\date{\today}
\title{Reversible Arithmetic on Collections}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.0)}}
\begin{document}

\maketitle
\tableofcontents


\begin{description}
\item[{Remark}] This is a literate program.
\footnote{\url{http://en.wikipedia.org/wiki/Literate_programming}.}
Source code \emph{and} PDF documentation spring
from the same, plain-text source files.
\end{description}

\section{Introduction}
\label{sec-1}

We often encounter data records or rows as hash-maps, lists, vectors
(also called \emph{arrays}). In our financial calculations, we often want
to add up a collection of such things, where adding two rows means
adding the corresponding elements and creating a new virtual row from
the result. We also want to \emph{un-add} so we can undo a mistake, roll
back a provisional result, perform a backfill or allocation: in short,
get back the original inputs. This paper presents a library supporting
reversible on a large class of collections in
Clojure.\footnote{\url{http://clojure.org}}
\section{Mathematical Background}
\label{sec-2}

Think of computer lists and vectors as \emph{mathematical vectors} familiar
from linear algebra:\footnote{\url{http://en.wikipedia.org/wiki/Linear_algebra}}
ordered sequences of numerical \emph{components} or \emph{elements}. Think of
hash-maps, which are equivalent to \emph{objects} in object-oriented
programming,\footnote{\url{http://en.wikipedia.org/wiki/Object-oriented_programming}}
as sparse vectors\footnote{\url{http://en.wikipedia.org/wiki/Sparse_vector}} of
\emph{named} elements.

Mathematically, arithmetic on vectors is straightforward: to add
them, just add the corresponding elements, first-with-first,
second-with-second, and so on.  Here's an example in two dimensions:
$$[1, 2] + [3, 4] = [4, 6]$$

Clojure's \emph{map} function does mathematical vector addition straight
out of the box on Clojure vectors and lists.  (We don't need to write
the commas, but we can if we want -- they're just whitespace in
Clojure):
\begin{verbatim}
(map + [1 2] [3 4])
\end{verbatim}

\begin{verbatim}
==> [4 6]
\end{verbatim}

With Clojure hash-maps, add corresponding elements via \emph{merge-with}:
\begin{verbatim}
(merge-with + {:x 1, :y 2} {:x 3, :y 4})
\end{verbatim}

\begin{verbatim}
==> {:x 4, :y 6}
\end{verbatim}

The same idea works in any number of dimensions and with any kind of
elements that can be added (any \emph{mathematical
field}:\footnote{\url{http://en.wikipedia.org/wiki/Field_(mathematics)}}
integers, complex numbers, quaternions -- many more.

Now, suppose you want to \emph{un-add} the result, \verb|[4 6]|? There is
no unique answer.  All the following are mathematically correct:
\begin{align*}
[-1, 2] + [5, 4] &= [4, 6] \\
[ 0, 2] + [4, 4] &= [4, 6] \\
[ 1, 2] + [3, 4] &= [4, 6] \\
[ 2, 2] + [2, 4] &= [4, 6] \\
[ 3, 2] + [1, 4] &= [4, 6] \\
\end{align*}
and a large infinity of more answers.
\section{A Protocol for Reversible Arithmetic}
\label{sec-3}

Let's define a protocol for \emph{reversible arithmetic in vector spaces}
that captures the desired functionality.  We want a \emph{protocol} --
Clojure's word for
\emph{interface},\footnote{\url{http://en.wikipedia.org/wiki/Interface_(computing)}}
because we want several implementations with the same reversible
arithmetic: one implementation for vectors and lists, another
implementation for hash-maps.  \emph{Protocols} let us ignore inessential
differences: the protocol for reversible arithmetic on is the same for
all compatible collection
types.\footnote{including streams over time! Don't forget Rx and SRS.}

Name our objects of interest \emph{algebraic vectors} to distinguish them
from Clojure's existing \emph{vector} type. Borrowing an idiom from C\# and
.NET, name our protocol with an initial \emph{I} and with camelback
casing.\footnote{\url{http://en.wikipedia.org/wiki/CamelCase}} Don't misread
\emph{IReversibleAlgebraicVector} as ``irreversible algebraic vector;''
rather read it as ``I Reversible Algebraic Vector'', i.e., ``Interface
to Reversible Algebraic Vector,'' where the ``I'' abbreviates
``Interface.''

We want to add, subtract, and scale our reversible vectors, just as we
can do with mathematical vectors.  Include inner product, since it is
likely to be useful.  Though we don't have immediate scenarios for
subtraction, scaling, and inner product, the mathematics tells us
they're fundamental. Putting them in our design \emph{now} affords two
benefits:
\begin{enumerate}
\item when the need arises, we won't have to change the code
\item their existence in the library may inspire usage scenarios
\end{enumerate}



\begin{description}
\item[{Remark}] The choice to include operations in a library in the absense
of scenarios is a philosophical
choice,\footnote{\url{http://en.wikipedia.org/wiki/Design_philosophy}}
perhaps more akin to \emph{Action-Centric} design or \emph{proactive}
design as opposed to \emph{Hyper-Rationalist} or \emph{minimalist}
design. The former philosophy promotes early inclusion of
facilities likely to be useful or inspirational, whereas the
latter philosophy demands ruthless rejection of facilities
not known to be needed. Both buy into to removing facilities
\emph{known to be not needed}, of course. The former philosophy
is based on intuition, judgment, and experience, and the
latter philosophy embraces ignorance of the future as a
design principle. We thus prefer the former.
\end{description}



Finally, we need undo and redo, the differentiating features of
reversible algebraic vectors. Here is our protocol design:

\begin{figure}[H]
\label{reversible-algebraic-vector-protocol}
\begin{verbatim}
(defprotocol IReversibleAlgebraicVector
  ;; binary operators
  (add   [a b])
  (sub   [a b])
  (inner [a b])
  ;; unary operators
  (scale [a scalar])
  ;; reverse any operation
  (undo [a])
  (redo [a])
)
\end{verbatim}
\end{figure}

\subsection{Implementing the Protocol for Vectors and Lists}
\label{sec-3-1}

As a first cut, let us define reversible vectors as algebraic vectors
wrapped in hash-maps that contain enough information to reverse
computations.

First, define the base case: collections that hold data that can be
treated as ordinary, non-reversible, algebraic vectors.  What kinds of
things can represent algebraic vectors?  Things we can operate on with
\emph{map} or \emph{merge-with} to perform basic vector-space operations.
Therefore, they must be Clojure vectors, lists, or hash-maps.

The higher-level case is to store reversing information in hash-maps
along with base-data. The base data will belong to the \emph{:a-vector} key, by
convention.

\begin{mydefinition}[Reversible Algebraic Vector (r-vector)]
  A \textbf{reversible algebraic vector} or \textbf{r-vector} is either
  a \textbf{a-vector} or a hash-map containing a \texttt{:a-vector}
  attribute. An a-vector is either a Clojure vector, list, or hash-map
  that does not contain a \texttt{:a-vector} attribute. If an r-vector
  does contain a \texttt{:a-vector} attribute, the value of that
  attribute is an a-vector.
\end{mydefinition}

Here is a \emph{fluent} type-checking function for base-data. It either
returns its input -- like the \emph{identity} function -- or throws an
exception if something is wrong.

\begin{figure}[H]
\label{check-data-type}
\begin{verbatim}
(defn- check-data-type [that]
  (let [t (type that)]
    (if (or (= t (type []))
            (= t (type '()))  ; empty list is special
            (= t (type '(0))) ; this list is ordinary
            (and (= t (type {})) (not (contains? that :a-vector))))
      that ; ok -- otherwose:
      (throw (IllegalArgumentException.
        (str "This type of object can't hold vector data: " t))))))
\end{verbatim}
\end{figure}

Now we need a way to get the data out of any reversible algebraic
vector.

If the input is a hash-map, we must explicitly check for existence of
\emph{:a-vector} so that we can tell the difference between a hash-map that has
\emph{:a-vector} whose value is \emph{nil}, which is an illegal case, and a hash-map
that has no \emph{:a-vector}, a legal case. We cannot simply apply the keyword
\emph{:a-vector} to the candidate reversible vector because that application
would produce \emph{nil} in both cases. Instead, we apply \emph{:a-vector} to the
candidate after checking for existence of the key, and then we apply
\emph{check-data-type}, defined above.

\begin{figure}[H]
\label{get-data-helper}
\begin{verbatim}
(defmulti  get-data type)
(defmethod get-data (type [])   [that] that)
(defmethod get-data (type '())  [that] that)
(defmethod get-data (type '(0)) [that] that)
(defmethod get-data (type {})   [that]
  (if (contains? that :a-vector)
    (check-data-type (:a-vector that))
    that))
(defmethod get-data :default    [that]
  (throw (IllegalArgumentException.
    (str "get-data doesn't like this food: " that))))
\end{verbatim}
\end{figure}

Now we write a test for all these cases. We require
\emph{IllegalArgumentExceptions} for bases-data blocks that are not vectors,
lists, or hash-maps or base-data blocks that contain
reversible-vectors: our design does not want to nest such vectors.

\begin{figure}[H]
\label{test-get-data-helper}
\begin{verbatim}
(deftest get-data-helper-test
  (testing "get-data-helper"
    ;; Negative tests
    (are [val] (thrown? IllegalArgumentException val)
      (get-data 42)
      (get-data 'a)
      (get-data :a)
      (get-data "a")
      (get-data \a)
      (get-data #inst "2012Z")
      (get-data #{})
      (get-data nil)
      (get-data {:a-vector 42 })
      (get-data {:a-vector 'a })
      (get-data {:a-vector :a })
      (get-data {:a-vector "a"})
      (get-data {:a-vector \a })
      (get-data {:a-vector #inst "2012Z"})
      (get-data {:a-vector #{} })
      (get-data {:a-vector nil })
      (get-data {:a-vector {:a-vector 'foo} })
    )
    ;; Positive tests
    (are [x y] (= x y)
          [] (get-data  [])
         '() (get-data '())
          {} (get-data  {})

         [0] (get-data  [0])
        '(0) (get-data '(0))
      {:a 0} (get-data  {:a 0})

       [1 0] (get-data  [1 0])
      '(1 0) (get-data '(1 0))
 {:a 0 :b 1} (get-data  {:b 1 :a 0})

        [42] (get-data {:a 1 :a-vector [42]})
       '(42) (get-data {:a 1 :a-vector '(42)})
     {:a 42} (get-data {:a 1 :a-vector {:a 42}})

          [] (get-data {:a 1 :a-vector []})
         '() (get-data {:a 1 :a-vector '()})
          {} (get-data {:a 1 :a-vector {}})
    )
))
\end{verbatim}
\end{figure}


To implement the protocol, we will need multimethods that dispatch on
the types of the base data. There is an example of this above in get
data; let's follow it to build add-data:

\begin{figure}[H]
\label{add-data}
\begin{verbatim}
(defn two-types [a b])
(defmulti  add-data two-types)
(defmethod add-data (type [])   [that] that)
(defmethod add-data (type '())  [that] that)
(defmethod add-data (type '(0)) [that] that)
(defmethod add-data (type {})   [that]
  (if (contains? that :a-vector)
    (check-data-type (:a-vector that))
    that))
(defmethod add-data :default    [that]
  (throw (IllegalArgumentException.
    (str "get-data doesn't like this food: " that))))
\end{verbatim}
\end{figure}


\begin{figure}[H]
\label{reversible-algebraic-vector-on-vector}
\begin{verbatim}
(defrecord ReversibleVector [a-vector]
  IReversibleAlgebraicVector
  (add   [a b] {:left-prior a, :right-prior b,
                :operation 'add, :a-vector (map + (get-data a)
                                              (get-data b))})
  (sub   [a b] nil)
  (inner [a b] nil)
  (scale [a scalar] nil)
  (undo  [a] nil)
  (redo  [b] nil))
\end{verbatim}
\end{figure}
\section{Unit-Tests}
\label{sec-4}

\begin{figure}[H]
\label{test-namespace}
\begin{verbatim}
(ns ex1.core-test
  (:require [clojure.test :refer :all]
            [ex1.core     :refer :all]))
\end{verbatim}
\end{figure}
\section{REPLing}
\label{sec-5}
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
\begin{enumerate}
\item Set up emacs and nRepl (TODO: explain; automate)
\item Edit your init.el file as follows (TODO: details)
\item Start nRepl while visiting the actual |project-clj| file.
\item Run code in the org-mode buffer with \verb|C-c C-c|; results of
evaluation are placed right in the buffer for inspection; they are
not copied out to the PDF file.
\end{enumerate}
% Emacs 24.3.1 (Org mode 8.0)
\end{document}
