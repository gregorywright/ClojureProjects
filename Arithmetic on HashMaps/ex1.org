#+TITLE: Reversible Arithmetic on Collections
#+AUTHOR: The Team of Fu
#+LATEX_HEADER: \usepackage{savesym}
#+LATEX_HEADER: \savesymbol{iint}
#+LATEX_HEADER: \savesymbol{iiint}
#+LATEX_HEADER: \usepackage{amsmath}

#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{tikz-cd}
#+LATEX_HEADER: \usetikzlibrary{matrix,arrows,positioning,scopes,chains}
#+LATEX_HEADER: \tikzset{node distance=2cm, auto}
#+LATEX_HEADER: \usepackage{framed}
#+LATEX_HEADER: \usepackage[framed]{ntheorem}
#+LATEX_HEADER: \newframedtheorem{myrule}{Rule}[section]
#+LATEX_HEADER: \newframedtheorem{mydefinition}{Definition}[section]
#+BEGIN_COMMENT
The following line generates a benign error
#+LATEX_HEADER: \usepackage{amsmath, amsthm, amssymb}
#+END_COMMENT
#+STYLE: <link rel="stylesheet" type="text/css" href="styles/default.css" />
#+BEGIN_COMMENT
  TODO: Integrate BibTeX
#+END_COMMENT

* Introduction
  + Remark :: This is a literate program.
              [fn:LP: http://en.wikipedia.org/wiki/Literate_programming.]
              Source code /and/ PDF documentation spring
              from the same, plain-text source files.

#+BEGIN_SRC clojure :tangle no
[1, 2] + [3, 4] = [4, 6]
#+END_SRC
We often encounter data records as hash-maps, sequences, or vectors.
Arithmetic on vectors is familiar from school math: to get the sum of
two vectors, just add the corresponding elements, first-to-first,
second-to-second, and so on.  Here's an example in two dimensions:

We don't need to write the commas (but we can if we want -- in Clojure,
they're just whitespace):
#+BEGIN_SRC clojure :tangle no
[1 2] + [3 4] = [4 6]
#+END_SRC

Clojure's /map/ can already do this:
#+BEGIN_SRC clojure :tangle no
(map + [1 2] [3 4])
#+END_SRC
\begin{verbatim}
==> [4 6]
\end{verbatim}

The same idea works in any number of dimensions and with any kind of
elements that can be added (any
/field/:[fn::http://en.wikipedia.org/wiki/Field_(mathematics)] integers,
complex numbers, quaternions.  It's the foundation of the important
theory of /Vector Spaces/ in
mathematics.[fn::http://en.wikipedia.org/wiki/Vector_space]

Now, suppose you want to /un-add/ the result, \verb|[4 6]|? There is no
unique answer.  All the following are mathematically correct:
#+BEGIN_SRC clojure :tangle no
...
[-1 2] + [5 4] = [4 6]
[ 0 2] + [4 4] = [4 6]
[ 1 2] + [3 4] = [4 6]
[ 2 2] + [2 4] = [4 6]
[ 3 2] + [1 4] = [4 6]
...
#+END_SRC
and a large infinity of more answers.

But, in our financial computations, we usually want this functionality
so we can undo a mistake, roll back a provisional result, perform a
backfill or allocation: in short, get back the original inputs.

Let's define a protocol for /reversible arithmetic in vector spaces/
that captures the desired functionality.  We want a protocol because we
want several implementations with the same reversible arithmetic.  For
instance, we should be able to do similarly for hash-maps, which, after
all, are just sparse vectors with named components:
#+BEGIN_SRC clojure :tangle no
{:x 1, :y 2} + {:x 3, :y} = {:x 4, y:6}
#+END_SRC

To get the desired behavior, we can't use /map/; it doesn't work the
same on hash-maps.  We must use Clojure's /merge-with/:
#+BEGIN_SRC clojure :tangle no
(merge-with + {:x 1, :y 2} {:x 3, :y 4})
#+END_SRC
\begin{verbatim}
==> {:y  6, :x 4}
\end{verbatim}

We want to get rid of these annoying differences: the protocol for
reversible arithmetic on data rows should be the same for all collection
types.[fn::including streams over time! Don't forget Rx and SRS.]  Along
the way, we'll do some hardening so that the implementations are robust
both mathematically and computationally.

* A Protocol for Reversible Arithmetic

Name our objects of interest /algebraic vectors/ to distinguish
them from Clojure's existing /vector/ type.  Borrowing an idiom from C\#
and .NET, name our protocol with an initial /I/ and with camelback
casing.  Don't misread /IReversibleAlgebraicVector/ as ``irreversible
algebraic vector,'' but rather read it as ``Interface to Reversible
Algebraic Vector,'' where ``Interface'' is a synonym for ``protocol.''

#+NAME: reversible-algebraic-vector-protocol
#+BEGIN_SRC clojure :tangle no
(defprotocol IReversibleAlgebraicVector
  ;; binary operators
  (add   [a b])
  (sub   [a b])
  (inner [a b])
  ;; unary operators
  (scale [a scalar])
  ;; reverse any operation
  (undo [a])
  (redo [a])
)
#+END_SRC

** Implementing the Protocol for Vectors

As a first cut, package algebraic vectors in hash-maps that contain
enough information to reverse any computation.

First, define the base case: collections that hold data that can be
treated as ordinary, non-reversible vectors.  What kinds of things can
hold ordinary vector data?  They be things we can operate on with /map/
or /merge-with/ to perform the basic, vector-space operations.
Therefore, the data must be a Clojure vector, list, or hash-map.

The higher-level case is to store reversing information in hash-maps
along with base-data. The base data will belong to the /:data/ key, by
convention.

\begin{mydefinition}[Reversible Algebraic Vector]
A \textbf{reversible algebraic vector} is either a \textbf{base-data} collection
or a hash-map containing a \texttt{:data} attribute. A base-data
collection is either a Clojure vector, list, or hash-map that does
not contain a \texttt{:data} attribute. If a reversible algebraic vector
does contain a \texttt{:data} attribute, the value of that attribute
is a base-data collection.
\end{mydefinition}

Here is a /fluent/, type-checking function that either returns its input
-- like the /identity/ function -- or throws an exception if something
is wrong.

#+NAME: check-data-type
#+BEGIN_SRC clojure :tangle no
(defn- check-data-type [that]
  (let [t (type that)]
    (if (or (= t (type []))
            (= t (type '()))  ; empty list is special
            (= t (type '(0))) ; this list is ordinary
            (= t (type {})))
      that
      (throw (IllegalArgumentException.
        (str "This type of object can't hold vector data: " t))))))
#+END_SRC

Now we can formally define the reversible algebraic vector:

Now we need a way to get the data out of any reversible algebraic
vector. We must explicitly check for existence of /:data/ so that we can
tell the difference between a hash-map that has /:data/ whose value is
/nil/ and a hash-map that has no /:data/; the prettier code

#+BEGIN_SRC clojure :tangle no
(:data that)
#+END_SRC

does not distinguish those two cases.

#+NAME: get-data-helper
#+BEGIN_SRC clojure :tangle no
(defmulti  get-data type)
(defmethod get-data (type [])   [that] that)
(defmethod get-data (type '())  [that] that)
(defmethod get-data (type '(0)) [that] that)
(defmethod get-data (type {})   [that]
  (if (contains? that :data)
    (check-data-type (:data that))
    that))
(defmethod get-data :default    [that]
  (throw (IllegalArgumentException.
    (str "get-data doesn't like this food: " that))))
#+END_SRC

#+name: test-get-data-helper
#+BEGIN_SRC clojure :results silent
(deftest get-data-helper-test
  (testing "get-data-helper"
    (are [val] (thrown? IllegalArgumentException val)
      (get-data 42)
      (get-data 'a)
      (get-data :a)
      (get-data "a")
      (get-data \a)
      (get-data #inst "2012Z")
      (get-data #{})
      (get-data nil)
      (get-data {:data 42 })
      (get-data {:data 'a })
      (get-data {:data :a })
      (get-data {:data "a"})
      (get-data {:data \a })
      (get-data {:data #inst "2012Z"})
      (get-data {:data #{} })
      (get-data {:data nil })
    )
    (are [x y] (= x y)
          [] (get-data  [])
         '() (get-data '())
          {} (get-data  {})

         [0] (get-data  [0])
        '(0) (get-data '(0))
      {:a 0} (get-data  {:a 0})

       [1 0] (get-data  [1 0])
      '(1 0) (get-data '(1 0))
 {:a 0 :b 1} (get-data  {:b 1 :a 0})

        [42] (get-data {:a 1 :data [42]})
       '(42) (get-data {:a 1 :data '(42)})
     {:a 42} (get-data {:a 1 :data {:a 42}})

          [] (get-data {:a 1 :data []})
         '() (get-data {:a 1 :data '()})
          {} (get-data {:a 1 :data {}})
    )
))
#+END_SRC

Here are unit tests for these helpers that show how they enforce the
definition.

#+NAME: reversible-algebraic-vector-on-vector
#+BEGIN_SRC clojure :tangle no
(defrecord ReversibleVector [a-vector]
  IReversibleAlgebraicVector
  (add   [a b] {:left-prior a, :right-prior b,
                :operation 'add, :data (map + (get-data a)
                                              (get-data b))})
  (sub   [a b] nil)
  (inner [a b] nil)
  (scale [a scalar] nil)
  (undo  [a] nil)
  (redo  [b] nil))
#+END_SRC

#+BEGIN_SRC markdown :mkdirp yes :tangle ./ex1/README.md :exports none
# ex1
A Clojure library for reversible arithmetic on collections.
## Usage
TODO
## License
Copyright Â© 2013 TODO
#+END_SRC
#+BEGIN_SRC clojure :noweb yes :mkdirp yes :tangle ./ex1/project.clj :exports none
(defproject ex1 "0.1.0-SNAPSHOT"
  :description "Project Fortune's Excel Processor"
  :url "http://example.com/TODO"
  :license {:name "TODO"
            :url "TODO"}
  :dependencies [[org.clojure/clojure  "1.5.1"]
                ]
  :repl-options {:init-ns ex1.core})
#+END_SRC
#+BEGIN_SRC markdown :mkdirp yes :tangle ./ex1/doc/intro.md :exports none
# Reversible Arithmetic on Collections
TODO: The project documentation is the .org file that produced
this output, but it still pays to read
http://jacobian.org/writing/great-documentation/what-to-write/
#+END_SRC
#+name: top-level-load-block
#+BEGIN_SRC clojure :exports none :mkdirp yes :tangle ./ex1/src/ex1/core.clj :padline no :results silent :noweb yes
<<main-namespace>>
<<reversible-algebraic-vector-protocol>>
<<check-data-type>>
<<get-data-helper>>
<<reversible-algebraic-vector-on-vector>>
#+END_SRC

#+name: main-namespace
#+BEGIN_SRC clojure :results silent :exports none
(ns ex1.core)
#+END_SRC

* Unit-Tests

#+BEGIN_SRC clojure  :exports none :mkdirp yes :tangle ./ex1/test/ex1/core_test.clj :padline no :results silent :noweb yes
<<test-namespace>>
<<test-get-data-helper>>
#+END_SRC

#+name: test-namespace
#+BEGIN_SRC clojure :results silent
(ns ex1.core-test
  (:require [clojure.test :refer :all]
            [ex1.core     :refer :all]))
#+END_SRC

* REPLing
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
1. Set up emacs and nRepl (TODO: explain; automate)
2. Edit your init.el file as follows (TODO: details)
3. Start nRepl while visiting the actual |project-clj| file.
4. Run code in the org-mode buffer with \verb|C-c C-c|; results of
   evaluation are placed right in the buffer for inspection; they are
   not copied out to the PDF file.
