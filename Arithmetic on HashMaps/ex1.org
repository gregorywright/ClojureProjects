#+TITLE: Arithmetic on Hash Maps
#+AUTHOR: The Team of Fu
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{tikz-cd}
#+LATEX_HEADER: \usetikzlibrary{matrix,arrows,positioning,scopes,chains}
#+LATEX_HEADER: \tikzset{node distance=2cm, auto}
#+BEGIN_COMMENT
The following line generates a benign error
#+LATEX_HEADER: \usepackage{amsmath, amsthm, amssymb}
#+END_COMMENT
#+STYLE: <link rel="stylesheet" type="text/css" href="styles/default.css" />
#+BEGIN_COMMENT
  TODO: Integrate BibTeX
#+END_COMMENT

* Introduction
  + Remark :: This is a literate program. 
              [fn:LP: See http://en.wikipedia.org/wiki/Literate_programming.] 
              Source code /and/ PDF documentation spring
              from the same, plain-text source files.

* Tangle to Leiningen

#+BEGIN_SRC text :mkdirp yes :tangle ./ex1/.gitignore :exports none
/target
/lib
/classes
/checkouts
pom.xml
pom.xml.asc
*.jar
*.class
.lein-deps-sum
.lein-failures
.lein-plugins
.lein-repl-history
#+END_SRC

#+BEGIN_SRC markdown :mkdirp yes :tangle ./ex1/README.md :exports none
# ex1
A Clojure library designed to do SOMETHING. 
## Usage
TODO
## License
Copyright Â© 2013 TODO
#+END_SRC

#+BEGIN_SRC clojure :noweb yes :mkdirp yes :tangle ./ex1/project.clj :exports none
  <<project-file>>
#+END_SRC

#+NAME: project-file
#+BEGIN_SRC clojure :tangle no
(defproject ex1 "0.1.0-SNAPSHOT"
  :description "Project Fortune's Excel Processor"
  :url "http://example.com/TODO"
  :license {:name "TODO"
            :url "TODO"}
  :dependencies [[org.clojure/clojure  "1.5.1"]
                 [org.clojure/data.zip "0.1.1"]
                 [dk.ative/docjure     "1.6.0"]
                ]
  :repl-options {:init-ns ex1.core})
#+END_SRC

#+BEGIN_SRC markdown :mkdirp yes :tangle ./ex1/doc/intro.md :exports none
# Introduction to ex1
TODO: The project documentation is the .org file that produced 
this output, but it still pays to read
http://jacobian.org/writing/great-documentation/what-to-write/
#+END_SRC
  
#+name: top-level-load-block
#+BEGIN_SRC clojure  :exports none :mkdirp yes :tangle ./ex1/src/ex1/core.clj :padline no :results silent :noweb yes
<<main-namespace>>
<<main-zippered>>
<<docjure-test-spreadsheet>>
#+END_SRC

*** The Namespace

#+name: main-namespace
#+BEGIN_SRC clojure :results silent 
(ns ex1.core
  (:use [clojure.data.zip.xml :only (attr text xml->)]
        [dk.ative.docjure.spreadsheet] ) 
  (:require [clojure.xml :as xml]
            [clojure.zip :as zip]))
#+END_SRC

*** Data Instances

#+name: main-zippered
#+BEGIN_SRC clojure :results silent 
(def xml (xml/parse "myfile.xml"))
(def zippered (zip/xml-zip xml))
#+END_SRC

*** A Test Excel Spreadsheet

#+name: docjure-test-spreadsheet
#+BEGIN_SRC clojure
(let [wb (create-workbook "Price List"
                          [["Name"       "Price"]
                           ["Foo Widget" 100]
                           ["Bar Widget" 200]])
      sheet (select-sheet "Price List" wb)
      header-row (first (row-seq sheet))]
  (do
    (set-row-style!
      header-row
      (create-cell-style! wb
        {:background :yellow,
         :font       {:bold true}}))
    (save-workbook! "spreadsheet.xlsx" wb)))
#+END_SRC

** Core Unit-Test File
  Unit-testing files go in a subdirectory named \verb+./ex1/test/ex1+.
  Again, the directory-naming convention enables valuable shortcuts
  from Leiningen.

#+BEGIN_SRC clojure  :exports none :mkdirp yes :tangle ./ex1/test/ex1/core_test.clj :padline no :results silent :noweb yes
<<main-test-namespace>>
<<test-zippered>>
<<test-docjure-read>>
#+END_SRC

As with the core source files, we include the built-in and downloaded
libraries, but also the \verb|test framework| and the \verb|core|
namespace, itself, so we can test the functions in the core.
#+name: main-test-namespace
#+BEGIN_SRC clojure :results silent 
(ns ex1.core-test
  (:use [clojure.data.zip.xml :only (attr text xml->)]
        [dk.ative.docjure.spreadsheet]
  )
  (:require [clojure.xml :as xml]
            [clojure.zip :as zip]
            [clojure.test :refer :all]
            [ex1.core :refer :all]))
#+END_SRC

We now test that the zippered XML file can be accessed by the /zipper/
operators. The main operator of interest is \verb|xml->|, which acts
a lot like Clojure's
/fluent-style/ [fn::http://en.wikipedia.org/wiki/Fluent_interface]
/threading/ operator
\verb|->|.[fn::http://clojuredocs.org/clojure_core/clojure.core/-\%3E]
It takes its first argument, a zippered XML file in this case, and
then a sequence of functions to apply. For instance, the following
XML file, when subjected to the functions \verb|:track|,
\verb|:name|, and \verb|text|, should produce \verb|'("Track one" "Track two")|
#+BEGIN_SRC xml :mkdirp yes :tangle ./ex1/myfile.xml
<songs>
  <track id="t1"><name>Track one</name></track>
  <ignore>pugh!</ignore>
  <track id="t2"><name>Track two</name></track>
</songs>
#+END_SRC
Likewise, we can dig into the attributes with natural accessor
functions [fn::Clojure treats colon-prefixed keywords as functions that
fetch the corresponding values from hashmaps, rather like the dot
operator in Java or JavaScript; Clojure also treats hashmaps as
functions of their keywords: the result of the function call
$\texttt{(\{:a 1\} :a)}$ is the same as the result of the function call
$\texttt{(:a \{:a 1\})}$ ]#+name: docjure-test-namespace

#+name: test-zippered
#+BEGIN_SRC clojure :results silent 
(deftest xml-zipper-test
  (testing "xml and zip on a trivial file."
    (are [a b] (= a b)
      (xml-> zippered :track :name text) '("Track one" "Track two")
      (xml-> zippered :track (attr :id)) '("t1" "t2"))))
#+END_SRC

Next, we ensure that we can faithfully read back the workbook we
created /via/ \verb|docjure|. Here, we use Clojure's
\verb|thread-last| macro to achieve fluent style:
#+name: test-docjure-read 
#+BEGIN_SRC clojure :results silent 
(deftest docjure-test
  (testing "docjure read"
    (is (= 

      (->> (load-workbook "spreadsheet.xlsx")
           (select-sheet "Price List")
           (select-columns {:A :name, :B :price}))
      
      [{:name "Name"      , :price "Price"}, ; don't forget header row
       {:name "Foo Widget", :price 100.0  },
       {:name "Bar Widget", :price 200.0  }]
      
      ))))
#+END_SRC

* A REPL-based Solution
\label{sec:emacs-repl}
To run the REPL for interactive programming and testing in org-mode,
take the following steps:
1. Set up emacs and nRepl (TODO: explain; automate)
2. Edit your init.el file as follows (TODO: details)
3. Start nRepl while visiting the actual |project-clj| file.
4. Run code in the org-mode buffer with \verb|C-c C-c|; results of
   evaluation are placed right in the buffer for inspection; they are
   not copied out to the PDF file.
  
#+BEGIN_SRC clojure :tangle no
[(xml-> zippered :track :name text)        ; ("Track one" "Track two")
 (xml-> zippered :track (attr :id))]       ; ("t1" "t2")
#+END_SRC

#+RESULTS:
| Track one | Track two |
| t1        | t2        |

#+BEGIN_SRC clojure :tangle no
(->> (load-workbook "spreadsheet.xlsx")
     (select-sheet "Price List")
     (select-columns {:A :name, :B :price}))
#+END_SRC

#+RESULTS:
| :price | Price | :name | Name       |
| :price | 100.0 | :name | Foo Widget |
| :price | 200.0 | :name | Bar Widget |

#+BEGIN_SRC clojure :tangle no
(run-all-tests)
#+END_SRC

#+RESULTS:
| :type | :summary | :pass | 115 | :test | 31 | :error | 0 | :fail | 0 |

* References

* Conclusion
  Fu is Fortune.
  
